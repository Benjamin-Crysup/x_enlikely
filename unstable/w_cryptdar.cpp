#include "whodun_cryptdar.h"

namespace whodun {

/**The substitutions for each byte.*/
extern short aesSbox[256];
/**The reverse substitutions.*/
extern short aesSboxInv[256];
/**The round constants.*/
extern short aesRcon[11];
/**Multiply by 2.*/
extern short aesGMult2[256];
/**Multiply by 3.*/
extern short aesGMult3[256];
/**Multiply by 9.*/
extern short aesGMult9[256];
/**Multiply by 11.*/
extern short aesGMult11[256];
/**Multiply by 13.*/
extern short aesGMult13[256];
/**Multiply by 14.*/
extern short aesGMult14[256];

/**
 * Add in the round key.
 * @param toMangle The stuff to mangle.
 * @param curKey The current key.
 */
void aesAddRoundKey(char* toMangle, char* curKey);
/**
 * Substitute the bytes.
 * @param toMangle The stuff to mangle.
 */
void aesSubBytes(char* toMangle);
/**
 * Shift the rows.
 * @param toMangle The stuff to mangle.
 */
void aesShiftRows(char* toMangle);
/**
 * Mix up the columns.
 * @param toMangle The stuff to mangle.
 */
void aesMixColumns(char* toMangle);

/**
 * Add in the round key.
 * @param toMangle The stuff to mangle.
 * @param curKey The current key.
 */
void aesUnAddRoundKey(char* toMangle, char* curKey);
/**
 * Substitute the bytes.
 * @param toMangle The stuff to mangle.
 */
void aesUnSubBytes(char* toMangle);
/**
 * Shift the rows.
 * @param toMangle The stuff to mangle.
 */
void aesUnShiftRows(char* toMangle);
/**
 * Mix up the columns.
 * @param toMangle The stuff to mangle.
 */
void aesUnMixColumns(char* toMangle);

/**
 * Actually perform encryption/decryption.
 * @param useKernel The aes kernel.
 * @param toDecrypt The data to decrypt.
 * @param useNonce The nonce.
 * @param counter The counter value.
 */
void aesCTRCrypt(AES256CryptoKernel* useKernel, char* toDecrypt, char* useNonce, uintptr_t counter);

/**Bulk decrypt*/
class AES256CTRDecryptLoop : public ParallelForLoop{
public:
	/**
	 * Set up the loop.
	 * @param numThread The number of threads to use.
	 */
	AES256CTRDecryptLoop(uintptr_t numThread);
	void doSingle(uintptr_t threadInd, uintptr_t ind);
	
	/**The counter value for the first block.*/
	uintptr_t counterOffset;
	/**The data to decrypt.*/
	char* toDecrypt;
	/**The nonce for this stream.*/
	char* useNonce;
	/**The key to use.*/
	AES256CryptoKernel* useKernel;
};

/**Bulk encrypt.*/
class AES256CTREncryptLoop : public ParallelForLoop{
public:
	/**
	 * Set up the loop.
	 * @param numThread The number of threads to use.
	 */
	AES256CTREncryptLoop(uintptr_t numThread);
	void doSingle(uintptr_t threadInd, uintptr_t ind);
	
	/**The counter value for the first block.*/
	uintptr_t counterOffset;
	/**The data to encrypt.*/
	const char* toEncrypt;
	/**The place to put it*/
	char* storeLoc;
	/**The nonce for this stream.*/
	char* useNonce;
	/**The key to use.*/
	AES256CryptoKernel* useKernel;
};

/**Round constants for SHA 256*/
extern uint32_t sha25RoundConsts[64];

};

using namespace whodun;

#define WHODUN_AES256KEYWORDS 8

AES256CryptoKernel::AES256CryptoKernel(char* useKey){
	memcpy(savedKey, useKey, WHODUN_AES256KEYSIZE);
	//precalculate the round keys
	uintptr_t numCalcWord = 4*(WHODUN_AES256ROUNDS+1);
	for(uintptr_t i = WHODUN_AES256KEYWORDS; i<numCalcWord; i++){
		unsigned char* curFocW = (unsigned char*)(savedKey + 4*i);
		uintptr_t focMod = i % WHODUN_AES256KEYWORDS;
		if(focMod == 0){
			curFocW[0] = curFocW[-32] ^ aesSbox[curFocW[-3]] ^ aesRcon[i / WHODUN_AES256KEYWORDS];
			curFocW[1] = curFocW[-31] ^ aesSbox[curFocW[-2]];
			curFocW[2] = curFocW[-30] ^ aesSbox[curFocW[-1]];
			curFocW[3] = curFocW[-29] ^ aesSbox[curFocW[-4]];
		}
		else if(focMod == 4){
			curFocW[0] = curFocW[-32] ^ aesSbox[curFocW[-4]];
			curFocW[1] = curFocW[-31] ^ aesSbox[curFocW[-3]];
			curFocW[2] = curFocW[-30] ^ aesSbox[curFocW[-2]];
			curFocW[3] = curFocW[-29] ^ aesSbox[curFocW[-1]];
		}
		else{
			curFocW[0] = curFocW[-32] ^ curFocW[-4];
			curFocW[1] = curFocW[-31] ^ curFocW[-3];
			curFocW[2] = curFocW[-30] ^ curFocW[-2];
			curFocW[3] = curFocW[-29] ^ curFocW[-1];
		}
	}
}
AES256CryptoKernel::~AES256CryptoKernel(){
	memset(savedKey, 0, (WHODUN_AES256ROUNDS+1)*WHODUN_AESBLOCK);
}
void AES256CryptoKernel::encrypt(char* toEncrypt){
	char* curRoundKey = savedKey;
	//start with the key
	aesAddRoundKey(toEncrypt, curRoundKey); curRoundKey += WHODUN_AESBLOCK;
	//middle rounds
	for(uintptr_t i = 1; i<WHODUN_AES256ROUNDS; i++){
		aesSubBytes(toEncrypt);
		aesShiftRows(toEncrypt);
		aesMixColumns(toEncrypt);
		aesAddRoundKey(toEncrypt, curRoundKey); curRoundKey += WHODUN_AESBLOCK;
	}
	//last round
	aesSubBytes(toEncrypt);
	aesShiftRows(toEncrypt);
	aesAddRoundKey(toEncrypt, curRoundKey); curRoundKey += WHODUN_AESBLOCK;
}
void AES256CryptoKernel::decrypt(char* toDecrypt){
	char* curRoundKey = savedKey + ((WHODUN_AES256ROUNDS+1)*WHODUN_AESBLOCK);
	//last round
	curRoundKey -= WHODUN_AESBLOCK; aesUnAddRoundKey(toDecrypt, curRoundKey);
	aesUnShiftRows(toDecrypt);
	aesUnSubBytes(toDecrypt);
	//middle rounds
	for(uintptr_t i = 1; i<WHODUN_AES256ROUNDS; i++){
		curRoundKey -= WHODUN_AESBLOCK; aesUnAddRoundKey(toDecrypt, curRoundKey);
		aesUnMixColumns(toDecrypt);
		aesUnShiftRows(toDecrypt);
		aesUnSubBytes(toDecrypt);
	}
	//start with the key
	curRoundKey -= WHODUN_AESBLOCK; aesUnAddRoundKey(toDecrypt, curRoundKey);
}

void whodun::aesAddRoundKey(char* toMangle, char* curKey){
	for(uintptr_t i = 0; i<WHODUN_AESBLOCK; i++){
		toMangle[i] = toMangle[i] ^ curKey[i];
	}
}
void whodun::aesSubBytes(char* toMangle){
	unsigned char* tmpMangle = (unsigned char*)toMangle;
	for(uintptr_t i = 0; i<WHODUN_AESBLOCK; i++){
		toMangle[i] = aesSbox[tmpMangle[i]];
	}
}
void whodun::aesShiftRows(char* toMangle){
	char tmpC;
	
	tmpC = toMangle[1];
	toMangle[1] = toMangle[5];
	toMangle[5] = toMangle[9];
	toMangle[9] = toMangle[13];
	toMangle[13] = tmpC;
	
	tmpC = toMangle[2];
	toMangle[2] = toMangle[10];
	toMangle[10] = tmpC;
	tmpC = toMangle[6];
	toMangle[6] = toMangle[14];
	toMangle[14] = tmpC;
	
	tmpC = toMangle[15];
	toMangle[15] = toMangle[11];
	toMangle[11] = toMangle[7];
	toMangle[7] = toMangle[3];
	toMangle[3] = tmpC;
}
void whodun::aesMixColumns(char* toMangle){
	unsigned char* r = (unsigned char*)toMangle;
	unsigned char tmpV[4];
	
	#define AES_MIX_SINGLE_COLUMN \
		tmpV[0] = aesGMult2[r[0]] ^ aesGMult3[r[1]] ^ r[2] ^ r[3];\
		tmpV[1] = r[0] ^ aesGMult2[r[1]] ^ aesGMult3[r[2]] ^ r[3];\
		tmpV[2] = r[0] ^ r[1] ^ aesGMult2[r[2]] ^ aesGMult3[r[3]];\
		tmpV[3] = aesGMult3[r[0]] ^ r[1] ^ r[2] ^ aesGMult2[r[3]];\
		r[0] = tmpV[0]; r[1] = tmpV[1]; r[2] = tmpV[2]; r[3] = tmpV[3];
	
	AES_MIX_SINGLE_COLUMN
	r += 4;
	
	AES_MIX_SINGLE_COLUMN
	r += 4;
	
	AES_MIX_SINGLE_COLUMN
	r += 4;
	
	AES_MIX_SINGLE_COLUMN
}

void whodun::aesUnAddRoundKey(char* toMangle, char* curKey){
	for(uintptr_t i = 0; i<WHODUN_AESBLOCK; i++){
		toMangle[i] = toMangle[i] ^ curKey[i];
	}
}
void whodun::aesUnSubBytes(char* toMangle){
	unsigned char* tmpMangle = (unsigned char*)toMangle;
	for(uintptr_t i = 0; i<WHODUN_AESBLOCK; i++){
		toMangle[i] = aesSboxInv[tmpMangle[i]];
	}
}
void whodun::aesUnShiftRows(char* toMangle){
	char tmpC;
	
	tmpC = toMangle[13];
	toMangle[13] = toMangle[9];
	toMangle[9] = toMangle[5];
	toMangle[5] = toMangle[1];
	toMangle[1] = tmpC;
	
	tmpC = toMangle[2];
	toMangle[2] = toMangle[10];
	toMangle[10] = tmpC;
	tmpC = toMangle[6];
	toMangle[6] = toMangle[14];
	toMangle[14] = tmpC;
	
	tmpC = toMangle[3];
	toMangle[3] = toMangle[7];
	toMangle[7] = toMangle[11];
	toMangle[11] = toMangle[15];
	toMangle[15] = tmpC;
}
void whodun::aesUnMixColumns(char* toMangle){
	unsigned char* r = (unsigned char*)toMangle;
	unsigned char tmpV[4];
	
	#define AES_UNMIX_SINGLE_COLUMN \
		tmpV[0] = aesGMult14[r[0]] ^ aesGMult11[r[1]] ^ aesGMult13[r[2]] ^ aesGMult9[r[3]];\
		tmpV[1] = aesGMult9[r[0]] ^ aesGMult14[r[1]] ^ aesGMult11[r[2]] ^ aesGMult13[r[3]];\
		tmpV[2] = aesGMult13[r[0]] ^ aesGMult9[r[1]] ^ aesGMult14[r[2]] ^ aesGMult11[r[3]];\
		tmpV[3] = aesGMult11[r[0]] ^ aesGMult13[r[1]] ^ aesGMult9[r[2]] ^ aesGMult14[r[3]];\
		r[0] = tmpV[0]; r[1] = tmpV[1]; r[2] = tmpV[2]; r[3] = tmpV[3];
	
	AES_UNMIX_SINGLE_COLUMN
	r += 4;
	
	AES_UNMIX_SINGLE_COLUMN
	r += 4;
	
	AES_UNMIX_SINGLE_COLUMN
	r += 4;
	
	AES_UNMIX_SINGLE_COLUMN
}

void whodun::aesCTRCrypt(AES256CryptoKernel* useKernel, char* toDecrypt, char* useNonce, uintptr_t counter){
	char mangleSeq[WHODUN_AESBLOCK];
	memcpy(mangleSeq, useNonce, WHODUN_AESCTRNONCE);
	BytePacker curPB(mangleSeq + 8);
	curPB.packBE64(counter);
	useKernel->encrypt(mangleSeq);
	for(uintptr_t i = 0; i<WHODUN_AESBLOCK; i++){
		toDecrypt[i] = toDecrypt[i] ^ mangleSeq[i];
	}
}

AES256CTRInStream::AES256CTRInStream(InStream* wrapStr, char* useKey, char* useNonce) : baseCrypt(useKey){
	baseStr = wrapStr;
	nextBlockIndex = 0;
	memcpy(nonce, useNonce, WHODUN_AESCTRNONCE);
	numOverhang = 0;
	usePool = 0;
	numThr = 1;
	saveDo = new AES256CTRDecryptLoop(numThr);
}
AES256CTRInStream::AES256CTRInStream(InStream* wrapStr, char* useKey, char* useNonce, uintptr_t numThread, ThreadPool* mainPool) : baseCrypt(useKey){
	baseStr = wrapStr;
	nextBlockIndex = 0;
	memcpy(nonce, useNonce, WHODUN_AESCTRNONCE);
	numOverhang = 0;
	usePool = 0;
	numThr = 1;
	saveDo = new AES256CTRDecryptLoop(numThr);
}
AES256CTRInStream::~AES256CTRInStream(){
	AES256CTRDecryptLoop* toKill = (AES256CTRDecryptLoop*)saveDo;
	delete(toKill);
}
int AES256CTRInStream::read(){
	char tmpR;
	uintptr_t numR = read(&tmpR, 1);
	if(numR == 0){ return -1; }
	return 0x00FF & tmpR;
}
uintptr_t AES256CTRInStream::read(char* toR, uintptr_t numR){
	//handle anything from the last round
	if(numOverhang){
		if(numOverhang >= numR){
			memcpy(toR, overhang + overhangOff, numR);
			numOverhang -= numR;
			overhangOff += numR;
			return numR;
		}
		uintptr_t saveOverhang = numOverhang;
		memcpy(toR, overhang + overhangOff, numOverhang);
		numOverhang = 0;
		return saveOverhang + read(toR + saveOverhang, numR - saveOverhang);
	}
	//handle even number of blocks
	uintptr_t numEvenBlocks = numR / WHODUN_AESBLOCK;
	uintptr_t numOddBytes = numR % WHODUN_AESBLOCK;
	if(numEvenBlocks){
		AES256CTRDecryptLoop* toLoop = (AES256CTRDecryptLoop*)saveDo;
		uintptr_t numReadBts = baseStr->read(toR, WHODUN_AESBLOCK*numEvenBlocks);
		//if not a full number of blocks read, nudge it up (and zero the uninitialized stuff)
		uintptr_t numReadBlock = numReadBts / WHODUN_AESBLOCK;
		if(numReadBts % WHODUN_AESBLOCK){
			numReadBlock++;
			memset(toR + numReadBts, 0, WHODUN_AESBLOCK*numReadBlock);
		}
		//decrypt
		toLoop->counterOffset = nextBlockIndex;
		toLoop->useNonce = nonce;
		toLoop->useKernel = &baseCrypt;
		if(usePool){ toLoop->doIt(usePool, 0, numReadBlock); }else{ toLoop->doIt(0, numReadBlock); }
		//decide what to do at the end
		nextBlockIndex += numReadBlock;
		if(numReadBts < (WHODUN_AESBLOCK*numEvenBlocks)){
			//hit end of file
			return numReadBts;
		}
		if(numOddBytes){
			return numReadBts + read(toR + numReadBts, numOddBytes);
		}
		return numReadBts;
	}
	//handle the leftovers
	if(numOddBytes){
		overhangOff = 0;
		numOverhang = baseStr->read(overhang, WHODUN_AESBLOCK);
		if(numOverhang == 0){ return 0; }
		if(numOverhang < WHODUN_AESBLOCK){
			memset(overhang + numOverhang, 0, WHODUN_AESBLOCK - numOverhang);
		}
		aesCTRCrypt(&baseCrypt, overhang, nonce, nextBlockIndex);
		nextBlockIndex++;
		return read(toR, numR);
	}
	return 0;
}
void AES256CTRInStream::close(){
	isClosed = 1;
}

AES256CTRRandaccInStream::AES256CTRRandaccInStream(RandaccInStream* wrapStr, char* useKey, char* useNonce){
	baseStr = wrapStr;
	needSeek = 0;
	focusInd = 0;
	totalNInd = wrapStr->size();
	realRead = new AES256CTRInStream(wrapStr, useKey, useNonce);
}
AES256CTRRandaccInStream::AES256CTRRandaccInStream(RandaccInStream* wrapStr, char* useKey, char* useNonce, uintptr_t numThread, ThreadPool* mainPool){
	baseStr = wrapStr;
	needSeek = 0;
	focusInd = 0;
	totalNInd = wrapStr->size();
	realRead = new AES256CTRInStream(wrapStr, useKey, useNonce, numThread, mainPool);
}
AES256CTRRandaccInStream::~AES256CTRRandaccInStream(){
	delete(realRead);
}
int AES256CTRRandaccInStream::read(){
	if(needSeek){ fixSeek(); }
	if(focusInd == totalNInd){ return -1; }
	focusInd++;
	return realRead->read();
}
uintptr_t AES256CTRRandaccInStream::read(char* toR, uintptr_t numR){
	if(needSeek){ fixSeek(); }
	uintmax_t maxNumR = totalNInd - focusInd;
	uintptr_t numToR = std::min((uintmax_t)numR, maxNumR);
	uintptr_t numActR = realRead->read(toR, numToR);
	focusInd += numActR;
	return numActR;
}
void AES256CTRRandaccInStream::close(){
	isClosed = 1;
	realRead->close();
}
uintmax_t AES256CTRRandaccInStream::tell(){
	return focusInd;
}
void AES256CTRRandaccInStream::seek(uintmax_t toLoc){
	focusInd = toLoc;
	needSeek = 1;
}
uintmax_t AES256CTRRandaccInStream::size(){
	return totalNInd;
}
void AES256CTRRandaccInStream::fixSeek(){
	needSeek = 0;
	if(focusInd == totalNInd){ return; }
	uintmax_t blockStart = (focusInd / WHODUN_AESBLOCK) * WHODUN_AESBLOCK;
	baseStr->seek(blockStart);
	realRead->numOverhang = 0;
	uintptr_t blockOff = focusInd - blockStart;
	if(blockOff){
		char tmpBuff[WHODUN_AESBLOCK];
		realRead->read(tmpBuff, blockOff);
	}
}

AES256CTROutStream::AES256CTROutStream(OutStream* wrapStr, char* useKey, char* useNonce) : baseCrypt(useKey){
	baseStr = wrapStr;
	nextBlockIndex = 0;
	memcpy(nonce, useNonce, WHODUN_AESCTRNONCE);
	numOverhang = 0;
	usePool = 0;
	numThr = 1;
	saveDo = new AES256CTREncryptLoop(numThr);
	packSize = 1024*numThr*WHODUN_AESBLOCK;
	packBuffer = (char*)malloc(packSize);
}
AES256CTROutStream::AES256CTROutStream(OutStream* wrapStr, char* useKey, char* useNonce, uintptr_t numThread, ThreadPool* mainPool) : baseCrypt(useKey){
	baseStr = wrapStr;
	nextBlockIndex = 0;
	memcpy(nonce, useNonce, WHODUN_AESCTRNONCE);
	numOverhang = 0;
	usePool = 0;
	numThr = 1;
	saveDo = new AES256CTREncryptLoop(numThr);
	packSize = 1024*numThr*WHODUN_AESBLOCK;
	packBuffer = (char*)malloc(packSize);
}
AES256CTROutStream::~AES256CTROutStream(){
	free(packBuffer);
	AES256CTREncryptLoop* toKill = (AES256CTREncryptLoop*)saveDo;
	delete(toKill);
}
void AES256CTROutStream::write(int toW){
	char workW = toW;
	write(&workW, 1);
}
void AES256CTROutStream::close(){
	if(numOverhang){
		memset(overhang, 0, WHODUN_AESBLOCK - numOverhang);
		aesCTRCrypt(&baseCrypt, overhang, nonce, nextBlockIndex);
		baseStr->write(overhang, numOverhang);
	}
	isClosed = 1;
}
void AES256CTROutStream::write(const char* toW, uintptr_t numW){
	if(numW == 0){ return; }
	//if not enough to fill the overhang, just copy and quit
	if((numW + numOverhang) < WHODUN_AESBLOCK){
		memcpy(overhang + numOverhang, toW, numW);
		numOverhang += numW;
		return;
	}
	//if enough to fill out an overhang, do so
	if(numOverhang){
		uintptr_t numG = WHODUN_AESBLOCK - numOverhang;
		memcpy(overhang + numOverhang, toW, numG);
		aesCTRCrypt(&baseCrypt, overhang, nonce, nextBlockIndex);
		baseStr->write(overhang, WHODUN_AESBLOCK);
		nextBlockIndex++;
		numOverhang = 0;
		write(toW + numG, numW - numG);
	}
	//make space for whole blocks
	uintptr_t numBlock = numW / WHODUN_AESBLOCK;
	uintptr_t blockBytes = numBlock * WHODUN_AESBLOCK;
	if(blockBytes > packSize){
		free(packBuffer);
		packSize = blockBytes;
		packBuffer = (char*)malloc(packSize);
	}
	//do the encryption
	AES256CTREncryptLoop* toLoop = (AES256CTREncryptLoop*)saveDo;
	toLoop->counterOffset = nextBlockIndex;
	toLoop->toEncrypt = toW;
	toLoop->storeLoc = packBuffer;
	toLoop->useNonce = nonce;
	toLoop->useKernel = &baseCrypt;
	if(usePool){ toLoop->doIt(usePool, 0, numBlock); }else{ toLoop->doIt(0, numBlock); }
	nextBlockIndex += numBlock;
	baseStr->write(packBuffer, blockBytes);
	//and dump any remainder
	write(toW + blockBytes, numW - blockBytes);
}

AES256CTRDecryptLoop::AES256CTRDecryptLoop(uintptr_t numThread) : ParallelForLoop(numThread){
	naturalStride = 128;
}
void AES256CTRDecryptLoop::doSingle(uintptr_t threadInd, uintptr_t ind){
	aesCTRCrypt(useKernel, toDecrypt + WHODUN_AESBLOCK*ind, useNonce, counterOffset + ind);
}
AES256CTREncryptLoop::AES256CTREncryptLoop(uintptr_t numThread) : ParallelForLoop(numThread){
	naturalStride = 128;
}
void AES256CTREncryptLoop::doSingle(uintptr_t threadInd, uintptr_t ind){
	char* workDump = storeLoc + WHODUN_AESBLOCK*ind;
	memcpy(workDump, toEncrypt + WHODUN_AESBLOCK*ind, WHODUN_AESBLOCK);
	aesCTRCrypt(useKernel, workDump, useNonce, counterOffset + ind);
}

short whodun::aesSbox[256] =  
 {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

short whodun::aesSboxInv[256] = {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d};

short whodun::aesRcon[11] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36};

short whodun::aesGMult2[256] = {
0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,	
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};
short whodun::aesGMult3[256] = {
0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,	
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,	
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,	
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,	
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};
short whodun::aesGMult9[256] = {
0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,	
0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,	
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,	
0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
};
short whodun::aesGMult11[256] = {
0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
};
short whodun::aesGMult13[256] = {
0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
};
short whodun::aesGMult14[256] = {
0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
};




SHA256HashKernel::SHA256HashKernel(){ reset(); }
SHA256HashKernel::~SHA256HashKernel(){}
void SHA256HashKernel::addBytes(SizePtrString toAdd){
	totalLength += toAdd.len;
	SizePtrString curAdd = toAdd;
	//add to the waiting buffer if any
	if(numStore){
		uintptr_t numCopy = (WHODUN_SHA256_CHUNKSIZE - numStore);
			numCopy = std::min(numCopy, curAdd.len);
		memcpy(tmpStoreBuff + numStore, curAdd.txt, numCopy);
		numStore += numCopy;
		curAdd.txt += numCopy;
		curAdd.len -= numCopy;
		if(numStore == WHODUN_SHA256_CHUNKSIZE){
			addChunk(tmpStoreBuff);
			numStore = 0;
		}
		else{ return; }
	}
	//add whole chunks
	while(curAdd.len >= WHODUN_SHA256_CHUNKSIZE){
		addChunk(curAdd.txt);
		curAdd.txt += WHODUN_SHA256_CHUNKSIZE;
		curAdd.len -= WHODUN_SHA256_CHUNKSIZE;
	}
	//store any remainder
	if(curAdd.len){
		memcpy(tmpStoreBuff, curAdd.txt, curAdd.len);
		numStore = curAdd.len;
	}
}
void SHA256HashKernel::getHash(char* toSave){
	//add the extra crap
	tmpStoreBuff[numStore] = 0x80;
	numStore++;
	uintptr_t numLeft = WHODUN_SHA256_CHUNKSIZE - numStore;
	memset(tmpStoreBuff + numStore, 0, WHODUN_SHA256_CHUNKSIZE - numStore);
	if(numLeft < 8){
		addChunk(tmpStoreBuff);
		memset(tmpStoreBuff, 0, WHODUN_SHA256_CHUNKSIZE);
	}
	BytePacker curPBA(tmpStoreBuff + (WHODUN_SHA256_CHUNKSIZE-8));
	curPBA.packBE64(totalLength);
	addChunk(tmpStoreBuff);
	//get the result
	for(int i = 0; i<8; i++){
		curPBA.retarget(toSave + (i<<2));
		curPBA.packBE32(hashVals[i]);
	}
	//and clear
	reset();
}
void SHA256HashKernel::reset(){
	hashVals[0] = 0X6A09E667ul;
	hashVals[1] = 0XBB67AE85ul;
	hashVals[2] = 0X3C6EF372ul;
	hashVals[3] = 0XA54FF53Aul;
	hashVals[4] = 0X510E527Ful;
	hashVals[5] = 0X9B05688Cul;
	hashVals[6] = 0X1F83D9ABul;
	hashVals[7] = 0X5BE0CD19ul;
	numStore = 0;
	totalLength = 0;
}
void SHA256HashKernel::addChunk(char* toAdd){
	//get the stuff in the chunk into the schedule
	uint32_t workSched[64];
	ByteUnpacker curPU;
	for(int i = 0; i<16; i++){
		curPU.retarget(toAdd + (i<<2));
		workSched[i] = curPU.unpackBE32();
	}
	//and fill out the rest of the schedule
	for(int i = 16; i<64; i++){
		uint32_t s0;
			uint32_t w15 = workSched[i-15];
			uint32_t w15rr7 = (w15 >> 7) | (w15 << 25);
			uint32_t w15rr18 = (w15 >> 18) | (w15 << 14);
			s0 = w15rr7 ^ w15rr18 ^ (w15 >> 3);
		uint32_t s1;
			uint32_t w2 = workSched[i-2];
			uint32_t w2rr17 = (w2 >> 17) | (w2 << 15);
			uint32_t w2rr19 = (w2 >> 19) | (w2 << 13);
			s1 = w2rr17 ^ w2rr19 ^ (w2 >> 10);
		workSched[i] = workSched[i-16] + s0 + workSched[i-7] + s1;
	}
	//make some temporary variables
	uint32_t a = hashVals[0];
	uint32_t b = hashVals[1];
	uint32_t c = hashVals[2];
	uint32_t d = hashVals[3];
	uint32_t e = hashVals[4];
	uint32_t f = hashVals[5];
	uint32_t g = hashVals[6];
	uint32_t h = hashVals[7];
	//do thing
	for(int i = 0; i<64; i++){
		uint32_t s1;
			uint32_t err6 = (e >> 6) | (e << 26);
			uint32_t err11 = (e >> 11) | (e << 21);
			uint32_t err25 = (e >> 25) | (e << 7);
			s1 = err6 ^ err11 ^ err25;
		uint32_t ch = (e & f) ^ ((~e) & g);
		uint32_t temp1 = h + s1 + ch + sha25RoundConsts[i] + workSched[i];
		uint32_t s0;
			uint32_t arr2 = (a >> 2) | (a << 30);
			uint32_t arr13 = (a >> 13) | (a << 19);
			uint32_t arr22 = (a >> 22) | (a << 10);
			s0 = arr2 ^ arr13 ^ arr22;
		uint32_t maj = (a & b) ^ (a & c) ^ (b & c);
		uint32_t temp2 = s0 + maj;
		h = g;
		g = f;
		f = e;
		e = d + temp1;
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
	}
	//and update hash values
    hashVals[0] = hashVals[0] + a;
    hashVals[1] = hashVals[1] + b;
    hashVals[2] = hashVals[2] + c;
    hashVals[3] = hashVals[3] + d;
    hashVals[4] = hashVals[4] + e;
    hashVals[5] = hashVals[5] + f;
    hashVals[6] = hashVals[6] + g;
    hashVals[7] = hashVals[7] + h;
}

uint32_t whodun::sha25RoundConsts[64] = {
0X428A2F98ul, 0X71374491ul, 0XB5C0FBCFul, 0XE9B5DBA5ul, 0X3956C25Bul, 0X59F111F1ul, 0X923F82A4ul, 0XAB1C5ED5ul,
0XD807AA98ul, 0X12835B01ul, 0X243185BEul, 0X550C7DC3ul, 0X72BE5D74ul, 0X80DEB1FEul, 0X9BDC06A7ul, 0XC19BF174ul,
0XE49B69C1ul, 0XEFBE4786ul, 0X0FC19DC6ul, 0X240CA1CCul, 0X2DE92C6Ful, 0X4A7484AAul, 0X5CB0A9DCul, 0X76F988DAul,
0X983E5152ul, 0XA831C66Dul, 0XB00327C8ul, 0XBF597FC7ul, 0XC6E00BF3ul, 0XD5A79147ul, 0X06CA6351ul, 0X14292967ul,
0X27B70A85ul, 0X2E1B2138ul, 0X4D2C6DFCul, 0X53380D13ul, 0X650A7354ul, 0X766A0ABBul, 0X81C2C92Eul, 0X92722C85ul,
0XA2BFE8A1ul, 0XA81A664Bul, 0XC24B8B70ul, 0XC76C51A3ul, 0XD192E819ul, 0XD6990624ul, 0XF40E3585ul, 0X106AA070ul,
0X19A4C116ul, 0X1E376C08ul, 0X2748774Cul, 0X34B0BCB5ul, 0X391C0CB3ul, 0X4ED8AA4Aul, 0X5B9CCA4Ful, 0X682E6FF3ul,
0X748F82EEul, 0X78A5636Ful, 0X84C87814ul, 0X8CC70208ul, 0X90BEFFFAul, 0XA4506CEBul, 0XBEF9A3F7ul, 0XC67178F2ul
};

